{
  "hash": "1c666c876bdba6d4688548659c2c5e36",
  "result": {
    "markdown": "# Save time, don't repeat yourself: Making functions {#sec-dry-functions}\n\n\n\n\n\nHere we will cover the second block, \"*Workflow*\" in\n@fig-overview-workflow.\n\n![Section of the overall workflow we will be\ncovering.](/images/overview-workflow.svg){#fig-overview-workflow}\n\n## Learning objectives\n\n1.  Learn what functions are in R and how to create and use them.\n2.  Learn a workflow of using Quarto / R Markdown, `source()` with\n    {{< var keybind.source >}} and restarting R with\n    {{< var keybind.restart-r >}} as a tool and process for developing\n    functions that can be later easily (re-)used.\n3.  Learn what R package dependency management is and how it can\n    simplify your data analysis work.\n4.  Continue practising Git version control to manage changes to your\n    files.\n\n## The basics of a function\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nWe've mentioned functions multiple times, but what is a function? At its\ncore, a function in R is anything that does an action. A function is a\nbundled sequence of steps that achieve a specific action. For instance,\nthe `+` (to add) is a function, `mean()` is a function, `[]` (to subset\nor extract) is a function, and so on. In simple terms, functions are\nmade of a function call, its arguments, and the function body:\n`function(argument1, argument2) { ...body with R code... }`.\n\nBecause R is open source, anyone can see how things work underneath. So,\nif we want to see what a function does underneath, we type out the\nfunction name without the `()` into the Console and run it. If we do it\nwith the function `sd()` which calculates the standard deviation, we\nsee:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> function (x, na.rm = FALSE) \n#> sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#>     na.rm = na.rm))\n#> <bytecode: 0x561708cefd90>\n#> <environment: namespace:stats>\n```\n:::\n:::\n\n\nHere you see `sd()` as the arguments `x` and `na.rm`. Within the\nfunction body is how it calculates the standard deviation, which is the\nsquare root of the variance. In this code, the `var()` is inside the\n`sqrt()` function, which is exactly what it should be.\n\nSo, if you learn how to create your own functions, it can make doing\nyour work easier and more efficient because you don't have to repeat\nyourself later. Making functions always has a basic structure of:\n\n1.  Giving a name to the function (e.g. `mean`).\n2.  Starting the function call using `function()`, assigning it to the\n    name with `<-`. This tells R that the name is a function object.\n3.  Optionally providing arguments to give to the function call, for\n    instance `function(argument1, argument2, argument3)`.\n4.  Filling out the body of the function, with the arguments (if any)\n    contained inside, that does some action.\n5.  Optionally, use `return()` to indicate what you want the function to\n    output. For learning purposes, we'll always use `return()` to help\n    show us what is the final function output.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nEmphasize that we will be using this workflow for creating functions all\nthe time throughout course and that this workflow is also what you'd use\nin your daily work.\n:::\n\nWhile there is no minimum or maximum number of arguments you can provide\nfor a function (e.g. you could have zero or dozens of arguments), its\ngood practice for yourself and for others to have as few arguments as\nnecessary to get the job done. So, the structure is:\n\n``` r\nname <- function(argument1, argument2) {\n    # body of function\n    output <- ... code ....\n    return(output)\n}\n```\n\nWriting your own functions can be absolutely amazing and fun and\npowerful... but you also often want to pull your hair out with\nfrustration at errors that are difficult to understand and fix. The best\nway to deal with this is by debugging. Due to time and to the challenge\nof making meaningful debugging exercises (solutions to problems are very\ndependent on the project), read @sec-extra-material in your own time for\nsome instructions on debugging and dealing with another common problem\nyou might encounter with R.\n:::\n\nLet's write a simple example. First, create a new Markdown header called\n`## Making a function` and create a code chunk below that with\n{{< var keybind.chunk >}} . Then, inside the function, we'll write this\ncode out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_numbers <- function(num1, num2) {\n  added <- num1 + num2\n  return(added)\n}\n```\n:::\n\n\nYou can use the new function by running the above code and writing out\nyour new function, with arguments to give it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_numbers(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] 3\n```\n:::\n:::\n\n\nThe function name is fairly good... `add_numbers` is read as \"add\nnumbers\". While we generally want to write code that describes what it\ndoes by reading it, it's also good practice to add some formal\ndocumentation to the function. Use the \"Insert Roxygen Skeleton\" in the\n\"Code\" menu, by typing {{< var keybind.roxygen >}}, and you can add\ntemplate documentation right above the function. It looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Title\n#'\n#' @param num1\n#' @param num2\n#'\n#' @return\n#' @export\n#'\n#' @examples\nadd_numbers <- function(num1, num2) {\n  added <- num1 + num2\n  return(added)\n}\n```\n:::\n\n\nIn the `Title` area, this is where you type out a brief sentence or\nseveral words that describe the function. Creating a new paragraph below\nthis line allows you to add a more detailed description. The other items\nare:\n\n-   `@param num`: These lines describe what each argument (also called\n    parameter) is for and what to give it.\n-   `@return`: This describes what output the function gives. Is it a\n    data.frame? A plot? What else does the output give?\n-   `@export`: Tells R that this function should be accessible to the\n    user of your package. Since we aren't making packages, delete it.\n-   `@examples`: Any lines below this are used to show examples of how\n    to use the function. This is very useful when making packages, but\n    not really in this case. So we'll delete it. Let's write out some\n    documentation for this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Add two numbers together.\n#'\n#' @param num1 A number here.\n#' @param num2 A number here.\n#'\n#' @return Returns the sum of the two numbers.\n#'\nadd_numbers <- function(num1, num2) {\n  added <- num1 + num2\n  return(added)\n}\n```\n:::\n\n\nOnce we've created that, let's open up the Git Interface with\n{{< var keybind.git >}} and **add and commit** these changes to our\nhistory.\n\n## Exercise: Brainstorm and discuss why and what you could make as a function\n\n> Time: 15 minutes.\n\nYou've learned the basics of making your own, custom function. Now, as a\ngroup, brainstorm and discuss some ways that you might make functions in\nyour own work to help reduce repetition. What type of code might you\nmake as a function for your own project? Do you think others, maybe in\nyour research group, might use this function too? Afterwards, all the\ngroups will briefly share what they thought of.\n\n## Making a function for vroom\n\nNow that we have a basic understanding of what a function looks like,\nlet's apply it to something we're doing right now: Importing our data.\n\nMaking functions is a series of steps:\n\n1.  Write code that works and does what you want.\n2.  Enclose it as a function with `name <- function() { ... }`, with an\n    appropriate and descriptive name.\n3.  Create arguments in the function call\n    (`function(argument1, argument2)`) with appropriate and descriptive\n    names, then replace the code with the argument names where\n    appropriate.\n4.  Rename any objects created to be more generic and include the\n    `return()` function at the end to indicate what the function will\n    output.\n5.  Run the function and check that it works.\n6.  Add the Roxygen documentation tags with {{< var keybind.roxygen >}}\n    while the cursor is in the function.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nEmphasize that we will be using this workflow for creating functions all\nthe time throughout course and that this workflow is also what you'd use\nin your daily work.\n:::\n\nSo, step one. Let's take the code we wrote for importing the `user_info`\ndata and convert that as a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_data <- vroom(\n  user_1_info_file,\n  col_select = -1,\n  col_types = cols(\n    gender = col_character(),\n    weight = col_double(),\n    height = col_double(),\n    age = col_double(),\n    .delim = \",\"\n  ),\n  .name_repair = snakecase::to_snake_case\n)\n```\n:::\n\n\nNext we wrap it in the function call and give it an appropriate name. In\nthis case, `import_user_info` is descriptive and meaningful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport_user_info <- function() {\n  user_1_info_data <- vroom(\n    user_1_info_file,\n    col_select = -1,\n    col_types = cols(\n      gender = col_character(),\n      weight = col_double(),\n      height = col_double(),\n      age = col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n}\n```\n:::\n\n\nThen, we add arguments in the function and replace within the code.\nHere, we have only one thing that we would change: The file path to the\ndataset. So, a good name might be `file_path`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport_user_info <- function(file_path) {\n  user_1_info_data <- vroom(\n    file_path,\n    col_select = -1,\n    col_types = cols(\n      gender = col_character(),\n      weight = col_double(),\n      height = col_double(),\n      age = col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n}\n```\n:::\n\n\nThen we clean things up by renaming `user_1_info_data` since we would\nlike to also import more than just `user_1`. A nice object name would be\n`info_data`. Add the `return()` function at the end with the object you\nwant your function to output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport_user_info <- function(file_path) {\n  info_data <- vroom(\n    file_path,\n    col_select = -1,\n    col_types = cols(\n      gender = col_character(),\n      weight = col_double(),\n      height = col_double(),\n      age = col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(info_data)\n}\n```\n:::\n\n\nGreat! Now we need to test it out. Let's try on two datasets, two\n`user_info.csv` files in the `user_1` and `user_2` folders.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport_user_info(here(\"data-raw/mmash/user_1/user_info.csv\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 1 × 4\n#>   gender weight height   age\n#>   <chr>   <dbl>  <dbl> <dbl>\n#> 1 M          65    169    29\n```\n:::\n\n```{.r .cell-code}\nimport_user_info(here(\"data-raw/mmash/user_2/user_info.csv\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 1 × 4\n#>   gender weight height   age\n#>   <chr>   <dbl>  <dbl> <dbl>\n#> 1 M          95    183    27\n```\n:::\n:::\n\n\nAwesome! It works. The final stage is adding the Roxygen documentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Import MMASH user info data file.\n#'\n#' @param file_path Path to user info data file.\n#'\n#' @return Outputs a data frame/tibble.\n#'\nimport_user_info <- function(file_path) {\n  info_data <- vroom(\n    file_path,\n    col_select = -1,\n    col_types = cols(\n      gender = col_character(),\n      weight = col_double(),\n      height = col_double(),\n      age = col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(info_data)\n}\n```\n:::\n\n\nA massive advantage of using functions is that if you want to make a\nchange to all your code, you can very easily do it by modifying the\nfunction and it will change all your other code too. Now that we have a\nworking function, run `{styler}` with {{< var keybind.styler >}} and\nthen let's **add and commit** it to the Git history with the RStudio Git\nInterface by using {{< var keybind.git >}}.\n\n## Exercise: Repeat with the saliva data\n\n> Time: 15 minutes.\n\nTake the code you created for importing the saliva data set from\n@sec-ex-import-saliva (*not* the code related to using `spec()`) and\nmake it into a function. It looks like the code below.\n\n``` r\nuser_1_saliva_data <- vroom(\n    user_1_saliva_file,\n    col_select = -1,\n    col_types = cols(\n        samples = col_character(),\n        cortisol_norm = col_double(),\n        melatonin_norm = col_double()  \n    ), \n    .name_repair = snakecase::to_snake_case\n)\n```\n\n::: {.callout-tip appearance=\"default\"}\nA helpful tip: To move around a Quarto / R Markdown or R script more\neasily, open up the \"Document Outline\" on the side by clicking the\nbutton in the top right corner of the Quarto / R Markdown pane or by\nusing {{< var keybind.outline >}}.\n:::\n\n1.  Create a new markdown header\n    `## Exercise for importing the saliva data as a function`.\n2.  Create a new code chunk below the header with\n    {{< var keybind.chunk >}}.\n3.  Paste the code you used from the exercise (shown above) into the\n    code chunk and begin converting it into a function, like we did\n    above.\n    -   Wrap it with the `function() {...}`\n    -   Make a meaningful name (use `import_saliva`)\n    -   Make an argument for the file path (`file_path`) and replace\n        `user_1_saliva_file` with `file_path` in the `vroom()` code\n    -   Rename the output object to `saliva_data` and put it in the\n        `return()` function\n    -   Run the function and then test that it works\n    -   Create the Roxygen documentation by adding it with\n\n        {{< var keybind.roxygen >}}\n\n\n4.  Run `{styler}` while in the `doc/learning.qmd` file with\n    {{< var keybind.styler >}}.\n\nUse the below code as a guide:\n\n``` r\n# Need to also add the Roxygen documentation \nimport_saliva <- function(file_path) {\n    # Paste the code to import saliva data you created \n    # from previous exercise\n    saliva_data <- ___(\n        ___\n    )\n    return(saliva_data)\n}\n\n# Test that the function works\n___(here(\"data-raw/mmash/user_1/saliva.csv\"))\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Import the MMASH saliva dataset.\n#'\n#' @param file_path Path to the user saliva data file.\n#'\n#' @return Outputs a data frame/tibble.\n#'\nimport_saliva <- function(file_path) {\n  saliva_data <- vroom(\n    file_path,\n    col_select = -1,\n    col_types = cols(\n      samples = col_character(),\n      cortisol_norm = col_double(),\n      melatonin_norm = col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(saliva_data)\n}\n\n# Test that this works\n# import_saliva(here(\"data-raw/mmash/user_1/saliva.csv\"))\n```\n:::\n\n\n## Continuing the workflow\n\nWe've created two functions. Now we need to move those functions from\nthe `doc/learning.qmd` file and into the `R/` folder. We do this for a\nfew reasons:\n\n1.  To prevent the Quarto / R Markdown document from becoming too long\n    and having a large portion of R code over other text.\n2.  To make it easier to maintain and find things in your project.\n3.  To make use of the `source()` function.\n\nWe want to store our functions in the file `R/functions.R` script so its\neasier to source them. Cut and paste *only* the `import_user_info()`\nfunction we created in `doc/learning.qmd`, including the Roxygen\ndocumentation, and paste it into the newly created `R/functions.R`.\n\nOnce we have it in there, let's test out the workflow. Restart our R\nsession with by either going to the \"Session -\\> Restart R\" menu item or\nby using the keybindings {{< var keybind.restart-r >}}. Move back into\nthe `doc/learning.qmd` and add `source(here(\"R/functions.R\"))` to the\ncode chunk called `setup` at the top. Run that line of code. Then go to\nwhere you wrote:\n\n``` r\nimport_user_info(here(\"data-raw/mmash/user_1/user_info.csv\"))\n```\n\nNow run this line. What happens now? You *may* get an error about not\nfinding the `vroom()` function. If you put `library(vroom)` in the\n`setup` code chunk, you might not get an error. If you did get an error,\nthat's because R doesn't know what the `vroom()` function is. This is\nwhere we start getting into package dependency management.\n\nWhat is package dependency management? Whenever you use an R package,\nyou depend on it for your code to work. The informal way to show what\npackages you use is by using the `library()` function. But if you come\nback to the project, or get a new computer, or someone else is working\non your project too, how will they know which packages your project\ndepends on? Do they have to search through all your files just to find\nall `library()` functions you used and then install those packages\nindividually? A much better way here is to formally indicate your\npackage dependency so that installing dependencies is easy. We do this\nby making use of the `DESCRIPTION` file.\n\nOpen up the `DESCRIPTION` file. You may or may not see something that\nlooks like:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\nType: Project\nPackage: LearnR3\nVersion: 0.0.1\nImports:\n    knitr,\n    rmarkdown\nEncoding: UTF-8\n```\n:::\n:::\n\n\nIf it doesn't look like this, replace all of your current text with the\ntext above. Notice the `Imports:` key. This is where information about\npackages are added. To quickly add a package, go to the **Console** and\ntype out:\n\n``` r\nusethis::use_package(\"vroom\")\n```\n\n\n::: {.cell}\n\n:::\n\n\nYou will see a bunch of text about adding it to `Imports`. If you look\nin your `DESCRIPTION` file now, you'll see something like:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\nType: Project\nPackage: LearnR3\nVersion: 0.0.1\nImports:\n    knitr,\n    rmarkdown,\n    vroom\nEncoding: UTF-8\n```\n:::\n:::\n\n\nNow, if you or someone else wants to install all the packages your\nproject depends on, they can do that by going to the **Console** and\nrunning:\n\n``` r\npak::pak()\n```\n\nThis function finds the `DESCRIPTION` file and installs all the packages\nin `Imports`. Let's add the other dependencies by typing in the\n**Console**:\n\n``` r\nusethis::use_package(\"here\")\nusethis::use_package(\"fs\")\nusethis::use_package(\"snakecase\")\n```\n\n\n::: {.cell}\n\n:::\n\n\nSince we will also make use of the tidyverse set of packages later in\nthe course, we'll also add tidyverse as a dependency. Since the\ntidyverse is a large collection of packages, the recommended way to add\nthis particular dependency is with:\n\n``` r\nusethis::use_package(\"tidyverse\", type = \"Depends\")\n```\n\n\n::: {.cell}\n\n:::\n\n\nIf you look in the `DESCRIPTION` file now, you see that the new\n`Depends` field has been added with `tidyverse` right below it. There\nare fairly technical reasons why we need to put tidyverse in the\n`Depends` field that you don't need to know about for this course, aside\nfrom the fact that it is a common practice in R projects. At least in\nthis context, we use the `Depends` field for tidyverse because of one\nbig reason: the `usethis::use_package()` function will complain if we\ntry to put tidyverse in the `Imports` and it recommends putting it in\nthe `Depends` field.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\nType: Project\nPackage: LearnR3\nVersion: 0.0.1\nDepends:\n    tidyverse\nImports:\n    fs,\n    here,\n    knitr,\n    rmarkdown,\n    snakecase,\n    vroom\nEncoding: UTF-8\n```\n:::\n:::\n\n\nGreat! Now that we've formally established package dependencies in our\nproject, we also need to formally declare which package each function\ncomes from inside our own functions.\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nBefore getting into the correct way, we need to quickly cover the\nincorrect way that you may or may not have seen how others have done it\non websites or in script files. Sometimes people use `library()` or\n`require()` inside functions like:\n\n``` r\nadd_numbers <- function(num1, num2) {\n    library(packagename)\n    ...code...\n    return(added)\n}\n```\n\nOr:\n\n``` r\nadd_numbers <- function(num1, num2) {\n    require(packagename)\n    ...code...\n    return(added)\n}\n```\n\nThis is *very* **bad practice** and can have some unintended and serious\nconsequences that you might not notice or that won't give any warning or\nerror. The correct way of indicating which package a function comes from\nis instead by using `packagename::`, which you've seen and used many\ntimes in this course. We won't get into the reasons why this is\nincorrect because it can quickly get quite technical.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nYou can also talk about why `require()` shouldn't be used compared to\n`library()`. The problem with `require()` is that if the package can't\nbe loaded, it won't throw an error, it only *checks* if the package is\navailable and will otherwise continue running the code. On the other\nhand, `library()` will throw an error if it can't find the package,\nwhich is what you expect if your code depends on a package.\n:::\n\nAnother reason to use `packagename::` for each function from an R\npackage you use in your own function is that it explicitly tells R (and\nus the readers) where the function comes from. Because the same function\nname can be used by multiple packages, if you don't explicitly state\nwhich package the function is from, R will use the function that it\nfinds first... which isn't always the function you meant to use. We also\ndo this step at the end of making the function because doing it while we\ncreate it can be quite tedious.\n:::\n\nAlright, let's go into `R/functions.R` and add `vroom::` to each of the\n`{vroom}` functions we've used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport_user_info <- function(file_path) {\n  info_data <- vroom::vroom(\n    file_path,\n    col_select = -1,\n    col_types = vroom::cols(\n      gender = vroom::col_character(),\n      weight = vroom::col_double(),\n      height = vroom::col_double(),\n      age = vroom::col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(info_data)\n}\n```\n:::\n\n\nTest that it works by restart the R session with\n{{< var keybind.restart-r >}} and source the file with\n{{< var keybind.source >}}, then go to the **Console** and type out:\n\n``` r\nimport_user_info(here::here(\"data-raw/mmash/user_1/user_info.csv\"))\n```\n\nIt should work as expected! Now that we've done that, let's **add and\ncommit** the changes made through the Git interface, using\n{{< var keybind.git >}}.\n\n## Exercise: Discuss why tracking dependencies might help you\n\n> Time: 5 minutes.\n\nBefore moving on to the next exercise, discuss with your group about:\n\n-   How tracking dependencies might help you in your own work.\n-   Some personal experiences, if you have had any, where the lack of\n    explicit dependencies made your work harder and more confusing.\n\n## Exercise: Move and update the rest of the functions\n\n> Time: 20 minutes.\n\nRepeat this process of making functions by doing this to the rest of the\ncode you worked on previously that imported the `RR.csv` and\n`Actigraph.csv` data.\n\n1.  Convert the importing code into functions while in the\n    `doc/lessons.Rmd` file. Include the Roxygen documentation and use\n    `packagename::` to be explicit about where the function comes from.\n\n    -   Name the new functions `import_rr` and `import_actigraph`.\n\n2.  Move the function into `R/functions.R`.\n\n3.  Restart R, `source()` the functions file, using\n    {{< var keybind.source >}}, and test that the functions work by\n    running them in the **Console**. The below code should run without a\n    problem if you did it right:\n\n    ``` r\n    import_rr(here(\"data-raw/mmash/user_1/RR.csv\"))\n    import_actigraph(here(\"data-raw/mmash/user_1/Actigraph.csv\"))\n    ```\n\n4.  Run `{styler}` while in the `R/functions.R` file with\n    {{< var keybind.styler >}}.\n\nAlso update the `import_saliva()` function you created by being explicit\nabout where the functions come from (e.g. with the `packagename::`).\nAfterwards, **add and commit** the changes to the Git history, using\n{{< var keybind.git >}}.\n\nUse this code template as a guide for making the functions.\n\n``` r\n# Insert Roxygen documentation too\n___ <- function(___) {\n    ___ <- ___::___(\n        ___,\n        col_select = ___,\n        col_types = ___::cols(\n            ___,\n            .delim = \",\"\n        ),\n        .name_repair = snakecase::to_snake_case\n    )\n    return(___)\n}\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Import the MMASH saliva dataset.\n#'\n#' @param file_path Path to the user saliva data file.\n#'\n#' @return Outputs a data frame/tibble.\n#'\nimport_saliva <- function(file_path) {\n  saliva_data <- vroom::vroom(\n    file_path,\n    col_select = -1,\n    col_types = vroom::cols(\n      samples = vroom::col_character(),\n      cortisol_norm = vroom::col_double(),\n      melatonin_norm = vroom::col_double(),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(saliva_data)\n}\n\n#' Import the MMASH RR dataset (heart beat-to-beat interval).\n#'\n#' @param file_path Path to the user RR data file.\n#'\n#' @return Outputs a data frame/tibble.\n#'\nimport_rr <- function(file_path) {\n  rr_data <- vroom::vroom(\n    file_path,\n    col_select = -1,\n    col_types = vroom::cols(\n      ibi_s = vroom::col_double(),\n      day = vroom::col_double(),\n      # Converts to seconds\n      time = vroom::col_time(format = \"\"),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(rr_data)\n}\n\n#' Import the MMASH Actigraph dataset (accelerometer).\n#'\n#' @param file_path Path to the user Actigraph data file.\n#'\n#' @return Outputs a data frame/tibble.\n#'\nimport_actigraph <- function(file_path) {\n  actigraph_data <- vroom::vroom(\n    file_path,\n    col_select = -1,\n    col_types = vroom::cols(\n      axis_1 = vroom::col_double(),\n      axis_2 = vroom::col_double(),\n      axis_3 = vroom::col_double(),\n      steps = vroom::col_double(),\n      hr = vroom::col_double(),\n      inclinometer_off = vroom::col_double(),\n      inclinometer_standing = vroom::col_double(),\n      inclinometer_sitting = vroom::col_double(),\n      inclinometer_lying = vroom::col_double(),\n      vector_magnitude = vroom::col_double(),\n      day = vroom::col_double(),\n      time = vroom::col_time(format = \"\"),\n      .delim = \",\"\n    ),\n    .name_repair = snakecase::to_snake_case\n  )\n  return(actigraph_data)\n}\n```\n:::\n\n\n## Summary\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nQuickly cover this before finishing the session and when starting the\nnext session.\n:::\n\n-   Functions in R are anything that does an action.\n-   Functions have five components:\n    -   The three required ones are the function call with\n        `function() { }`, the function body between the `{ }`, and an\n        output (usually set with `return()`).\n    -   The two optional ones are assigning the function to a named\n        object with `<-` and the function arguments put within\n        `function()`.\n-   Write function documentation by using Roxygen.\n-   Use `use_package()` for the `DESCRIPTION` file as well as\n    `packagename::functionname()` to explicit state the packages your\n    function depends on.\n    -   Don't use `library()` or `require()` *within* your function.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}