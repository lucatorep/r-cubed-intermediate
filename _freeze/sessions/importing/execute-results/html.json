{
  "hash": "a2e04299dbfb216cc6f44e480ea340ea",
  "result": {
    "markdown": "# Importing data, fast! {#sec-import-data}\n\n\n\n\n\nDuring this session we'll be introducing concepts for both the\n\"*Download raw data*\" block as well as the \"*Workflow*\" block in\n@fig-overview-download-data. You already downloaded and unzipped the raw\ndata during the [pre-course](/preamble/pre-course.qmd) tasks and here\nwe'll continue the process by now importing it into R.\n\n![Section of the overall workflow we will be\ncovering.](/images/overview-download-data.svg){#fig-overview-download-data}\n\nRight now, your folder and file structure should look like (use\n`fs::dir_tree(recurse = 2)` if you want to check using R):\n\n```         \nLearnR3\n├── data/\n│   └── README.md\n├── data-raw/\n│   ├── README.md\n│   ├── mmash-data.zip\n│   ├── mmash/\n│   │  ├── user_1\n│   │  ├── ...\n│   │  └── user_22\n│   └── mmash.R\n├── doc/\n│   ├── README.md\n│   └── lesson.qmd\n├── R/\n│   ├── functions.R\n│   └── README.md\n├── .gitignore\n├── DESCRIPTION\n├── LearnR3.Rproj\n└── README.md\n```\n\n## Learning objectives\n\n1.  Learn how to import data and do minor cleaning with the `{vroom}`\n    package.\n2.  Learn about strategies and resources to use when encountering\n    problems when importing data (arguably one of the most important\n    skills in any coding-type work).\n3.  Understand and apply best practices for importing data quickly.\n4.  Practice using Git version control as part of the data analysis\n    workflow.\n\n## Importing in the raw data\n\nThe ultimate goal for the beginning phases of a data analysis project is\nto eventually save a version of the raw data that is specific to your\nresearch questions. The first step to processing data is to import it\ninto R so we can work on it. So for now, we'll open up the\n`doc/learning.qmd` file so we can start building and testing out the\ncode. At the bottom of the file, create a new header by typing out\n`## Importing raw data`. Right below the header, make a new code chunk\nwith {{< var keybind.chunk >}} and call it `setup`. Inside the code\nchunk, load the `{vroom}` package with `library(vroom)` as well as\n`library(here)`. Since we'll also be using the `{tidyverse}` package,\nlet's also add `library(tidyverse)`. It should look like this:\n\n````         \n```{{r setup}}\nlibrary(tidyverse)\nlibrary(vroom)\nlibrary(here)\n```\n````\n\nThis is a special, named code chunk that tells R to run this code chunk\nfirst whenever you open this Quarto / R Markdown file and run code\ninside of the file. It's in this `setup` code chunk that we will add\n`library()` functions when we want to load other packages. After adding\nthis code chunk, create a new code chunk right below it using\n{{< var keybind.chunk >}}.\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nWhat is `{vroom}`? It is a package designed to load in data,\nspecifically text-based data files such as CSV. In R there are several\npackages that you can use to load in data and of different types of file\nformats. We won't cover these other packages, so you can use this as a\nreference for when or if you ever have to load other file types:\n\n-   `{haven}`: For reading (also known as importing or loading) in SAS,\n    SPSS, and Stata files.\n-   `{readxl}`: For reading in Excel spreadsheets with `.xls` or `.xlsx`\n    file endings.\n-   `{googlesheets4}`: For reading in Google Sheets from their cloud\n    service.\n-   `{readr}`: Standard package used to load in text-based data files\n    like CSV. This package is included by default within the\n    `{tidyverse}`. Newer versions of `{readr}` actually use `{vroom}`\n    internally, but we'll still cover `{vroom}` separately in this\n    course.\n-   `utils::read.delim()`: This function comes from the core R package\n    utils and includes other functions like `utils::read.csv()` (note\n    the `.` in the name, rather than `_` in the `readr::read_csv()`\n    version).\n-   `data.table::fread()`: From the `{data.table}` package, this\n    function is used to load in CSV files.\n\nWe're using the `{vroom}` package for largely one reason: It makes use\nof recent improvements in R that allow data to be imported into R very\nvery quickly. Just how fast? The `{vroom}` website has a [benchmark\npage](https://vroom.r-lib.org/articles/benchmarks.html) showing how fast\nit is. For many people, loading in the data can be one of the most\ntime-consuming parts of starting an analysis. Hopefully by using this\npackage, that time can be reduced.\n\nThe packages `{readr}`, `{vroom}`, `{haven}`, `{readxl}`, and\n`{googlesheets4}` all are very similar in how you use them and their\ndocumentation are almost identical. So the skills you learn in this\nsession with `{vroom}` can mostly be applied to these other packages.\nAnd because `{readr}` (which the other packages are based on) has been\naround for awhile, there is a large amount of support and help for using\nit.\n\nIf your data is in CSV format, `{vroom}` is perfect. The CSV file format\nis a commonly used format for data because it is open and transparent,\nreadable by any computer, and doesn't depend on any special software to\nopen (unlike for e.g. Excel spreadsheets).\n:::\n\nLet's first start by creating an object that has the file path to the\ndataset, then we'll use `vroom()` to import that dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_file <- here(\"data-raw/mmash/user_1/user_info.csv\")\nuser_1_info_data <- vroom(user_1_info_file)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> New names:\n#> Rows: 1 Columns: 5\n#> ── Column specification\n#> ──────────────────────────────────────────── Delimiter: \",\" chr\n#> (1): Gender dbl (4): ...1, Weight, Height, Age\n#> ℹ Use `spec()` to retrieve the full column specification for this\n#> data. ℹ Specify the column types or set `show_col_types = FALSE` to\n#> quiet this message.\n#> • `` -> `...1`\n```\n:::\n:::\n\n\nYou'll see the output mention using `spec()` to use in the argument\n`col_types`. And that it has 5 columns, one called `...1`. If we look at\nthe CSV file though, we see that there are only four columns with\nnames... but that technically there is a first empty column without a\ncolumn header. So, let's figure out what this message means. Let's go to\nthe **Console** and type out:\n\n``` r\n?vroom::spec\n```\n\nIn the documentation, we see that it says:\n\n> \"extracts the full column specification from a tibble...\"\n\nWithout seeing the output, it's not clear what \"specification\" means.\nUse `spec()` on the dataset object. In the **Console** again:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspec(user_1_info_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> cols(\n#>   ...1 = col_double(),\n#>   Gender = col_character(),\n#>   Weight = col_double(),\n#>   Height = col_double(),\n#>   Age = col_double(),\n#>   .delim = \",\"\n#> )\n```\n:::\n:::\n\n\nThis shows that a specification is a list and description of which\ncolumns are imported into R and what data types they are given. For\ninstance, `col_double()` means numeric (double is how computers\nrepresent non-integer numbers) and `col_character()` means a character\ndata type. Next, let's see what the message meant about `col_types`.\nLet's check out the help documentation for `vroom()` by typing in the\n**Console**:\n\n``` r\n?vroom::vroom\n```\n\nAnd if we scroll down to the explanation of `col_types`:\n\n> \"One of NULL, a cols() specification, or a string. See\n> vignette(\"readr\") for more details.\"\n\nIt says to use a \"cols() specification\", which is the output of\n`spec()`. Copy the output from `spec()` and paste it into the\n`col_types` argument of `vroom()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_data <- vroom(\n  user_1_info_file,\n  col_types = cols(\n    ...1 = col_double(),\n    Gender = col_character(),\n    Weight = col_double(),\n    Height = col_double(),\n    Age = col_double()\n  )\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> New names:\n#> • `` -> `...1`\n```\n:::\n:::\n\n\nWe get a funny message though. We copied and pasted, so what's going on?\nIf you recall, the `user_info.csv` file has an empty column name.\nLooking at the [data\ndictionary](https://physionet.org/content/mmash/1.0.0/) it doesn't seem\nthere is any reference to this column, so it likely isn't important.\nMore than likely, `{vroom}` is complaining about this empty column name\nand the use of `...1` to represent it. We don't need it, so we'll get\nrid of it when we load in the dataset. But how? Look at the help\ndocumentation again. Go to the **Console** and type out:\n\n``` r\n?vroom::vroom\n```\n\nLooking at the list of arguments, there is an argument called\n`col_select` that sounds like we could use that to keep or drop columns.\nIt says that it is used similar to `dplyr::select()`, which normally is\nused with actual column names. Our column doesn't have a name, that's\nthe problem. Next check the Example section of the help. Scrolling down,\nyou'll eventually see:\n\n> `vroom(input_file, col_select = c(1, 3, 11))`\n\nSo, it takes numbers! With `dplyr::select()`, using the `-` before the\ncolumn name (or number) means to drop the column, so in this case, we\ncould drop the first column with `col_select = -1`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_data <- vroom(\n  user_1_info_file,\n  col_select = -1,\n  col_types = cols(\n    ...1 = col_double(),\n    Gender = col_character(),\n    Weight = col_double(),\n    Height = col_double(),\n    Age = col_double()\n  )\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> New names:\n#> • `` -> `...1`\n```\n:::\n:::\n\n\nHmm, we still have the message. You may or may not see this message\ndepending on the version of your packages (the most updated packages\nwill show this), but you can see it in the code chunk above.\n\nThis is `vroom()` letting you know that a column was renamed because it\nfound an empty column with no column name and is letting you know it had\nto rename it. Even though we excluded it with `col_select = -1`, that\nonly excludes it after reading the column names, before importing the\ndata.\n\nTo remove this new message, we need to tell `vroom()` exactly how to\nhandle renaming cases. Let's look at the help docs of `{vroom}`:\n`?vroom`. Scroll down and we see an argument called `.name_repair` that\nhandles naming of columns. Going into the provided link takes us to the\n`tibble::tibble()` help documentation. Scroll down to the `.name_repair`\nargument documentation and it says that it treats problematic column\nnames, of which a missing column name is definitely a problem. There are\nseveral options here, but the one I want to focus on is the comment\nabout \"function: apply custom name repair\". This is an important one\nbecause we eventually want to rename the columns to match the [style\nguide](https://style.tidyverse.org/) by using `snake_case`, since there\nis a package to do that called `{snakecase}`.\n\nIn the **Console**, type out `snakecase::` and hit Tab. You'll see a\nlist of possible functions to use. We want to use the snakecase one, so\nscroll down and find the `to_snake_case()`. That's the one we want to\nuse. So to remove the messages and convert the variable names to snake\ncase, we would add `.name_repair = snakecase::to_snake_case` to the\ncode. Notice the lack of `()` when using the function. We'll explain\nmore about this in later sessions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_data <- vroom(\n  user_1_info_file,\n  col_select = -1,\n  col_types = cols(\n    ...1 = col_double(),\n    Gender = col_character(),\n    Weight = col_double(),\n    Height = col_double(),\n    Age = col_double()\n  ),\n  .name_repair = snakecase::to_snake_case\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: The following named parsers don't match the column names:\n#> ...1, Gender, Weight, Height, Age\n```\n:::\n:::\n\n\nNow we have another warning though. It's probably because the names are\nrepaired to snake case before the `col_types` are used. Let's try\nrepeating the `vroom()` to `spec()` to `vroom()` workflow we just used\nto see if that fixes the problem.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_data <- vroom(\n  user_1_info_file,\n  col_select = -1,\n  .name_repair = snakecase::to_snake_case\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Rows: 1 Columns: 4\n#> ── Column specification ────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr (1): gender\n#> dbl (3): weight, height, age\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nspec(user_1_info_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> cols(\n#>   col_skip(),\n#>   gender = col_character(),\n#>   weight = col_double(),\n#>   height = col_double(),\n#>   age = col_double(),\n#>   .delim = \",\"\n#> )\n```\n:::\n\n```{.r .cell-code}\nuser_1_info_data <- vroom(\n  user_1_info_file,\n  col_select = -1,\n  col_types = cols(\n    col_skip(),\n    gender = col_character(),\n    weight = col_double(),\n    height = col_double(),\n    age = col_double(),\n    .delim = \",\"\n  ),\n  .name_repair = snakecase::to_snake_case\n)\n```\n:::\n\n\nThat fixed it! No more messages or warnings! We can now look at the\ndata:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_info_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 1 × 4\n#>   gender weight height   age\n#>   <chr>   <dbl>  <dbl> <dbl>\n#> 1 M          65    169    29\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nVerbally emphasize that when you read from a larger dataset (that isn't\nyour project dataset), its better to *explicitly* select the columns you\nwant. It's faster to import and you make it clear from the beginning\nwhich variables you want.\n:::\n\nWhy might we use `spec()` and `col_types`? It's good practice, at least\nwhen reading from a larger dataset and not your project specific\ndataset, to read *only* the columns you need. Depending on the size of\nthe dataset, it could take a long time to load everything, which may not\nbe very efficient if you only intend to use some parts of the dataset\nand not all of it. And sometimes, `spec()` incorrectly guesses the\ncolumn types, so using `col_types = cols()` can fix those problems.\n\nIf you have a lot of columns in your dataset, then you can make use of\n`col_select` or `cols_only()` to keep only the columns you want. Before\nmoving on to the exercise, run `{styler}` with\n{{< var keybind.styler >}}, then **add and commit** the changes to the\nGit history through the RStudio Git interface with\n{{< var keybind.git >}}.\n\n## Exercise: Import the saliva data {#sec-ex-import-saliva}\n\n> Time: 15 minutes.\n\nPractice importing data files by doing the same process with the saliva\ndata.\n\n1.  Create a new header at the bottom of the `doc/learning.qmd` file and\n    call it `## Exercise: Import the saliva data`.\n2.  Below the header, create a new code chunk with\n    {{< var keybind.chunk >}}.\n3.  Copy and paste the code template below into the new code chunk.\n    Begin replacing the `___` with the correct R functions or other\n    information.\n4.  Once you have the code working, run `{styler}` with\n    {{< var keybind.styler >}} and then use the RStudio Git interface to\n    **add and commit** the changes to the Git history using\n    {{< var keybind.git >}}.\n\n``` r\nuser_1_saliva_file <- here(\"data-raw/mmash/user_1/___\")\nuser_1_saliva_data_prep <- vroom(\n    user_1_saliva_file,\n    col_select = ___,\n    .name_repair = ___\n)\n___(user_1_saliva_data_prep)\n\nuser_1_saliva_data <- vroom(\n    user_1_saliva_file,\n    col_select = ___,\n    col_types = ___,\n    .name_repair = ___\n)\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\nuser_1_saliva_file <- here(\"data-raw/mmash/user_1/saliva.csv\")\nuser_1_saliva_data_prep <- vroom(\n  user_1_saliva_file,\n  col_select = -1,\n  .name_repair = snakecase::to_snake_case\n)\nspec(user_1_saliva_data_prep)\n\nuser_1_saliva_data <- vroom(\n  user_1_saliva_file,\n  col_select = -1,\n  col_types = cols(\n    col_skip(),\n    samples = col_character(),\n    cortisol_norm = col_double(),\n    melatonin_norm = col_double()\n  ),\n  .name_repair = snakecase::to_snake_case\n)\n```\n:::\n\n\n## Importing larger datasets\n\nSometimes you may have a dataset that's just a bit too large. Sometimes\n`{vroom}` may not have enough information to guess the data type of the\ncolumn. Or maybe there are hundreds or thousands of columns in your data\nand you only want to import specific columns. In these cases, we can do\na trick: read in the first few lines of the dataset, use `spec()` and\npaste in the output into the `col_type` argument, and then keep only the\ncolumns you want to keep.\n\nLet's do this on the `RR.csv` file. We can see from the file size that\nit is bigger than most of the other files (\\~2Mb). So, we'll use this\ntechnique to decide what we want to keep. First, create a new header\n`## Import larger datasets` and a new code chunk below it using\n{{< var keybind.chunk >}}.\n\nDo the same thing that we've been doing, but this time we are going to\nuse the argument `n_max`, which tells `{vroom}` how many rows to read\ninto R. In this case, let's read in 100, since that is the amount\n`{vroom}` will guess until. This dataset, like the others, has an empty\ncolumn that we will drop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_rr_file <- here(\"data-raw/mmash/user_1/RR.csv\")\nuser_1_rr_data_prep <- vroom(\n  user_1_rr_file,\n  n_max = 100,\n  col_select = -1,\n  .name_repair = snakecase::to_snake_case\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Rows: 100 Columns: 3\n#> ── Column specification ────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl  (2): ibi_s, day\n#> time (1): time\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nspec(user_1_rr_data_prep)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> cols(\n#>   col_skip(),\n#>   ibi_s = col_double(),\n#>   day = col_double(),\n#>   time = col_time(format = \"\"),\n#>   .delim = \",\"\n#> )\n```\n:::\n:::\n\n\nLike with last time, copy and paste the output into a new use of\n`vroom()`. Add the `.name_repair` argument with\n`snakecase::to_snake_case`. Don't forget to also remove the last `,` at\nthe end! Make sure to remove the `n_max` argument, since we want to\nimport in the whole dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_rr_data <- vroom(\n  user_1_rr_file,\n  col_select = -1,\n  col_types = cols(\n    col_skip(),\n    ibi_s = col_double(),\n    day = col_double(),\n    # Converts to seconds\n    time = col_time(format = \"\")\n  ),\n  .name_repair = snakecase::to_snake_case\n)\n```\n:::\n\n\nThere's a new column type: `col_time()`. To see all the other types of\ncolumn specifications, in the **Console** type out `col_` and then hit\nthe Tab key. You'll see other types, like `col_date`, `col_factor`, and\nso on. Right, back to the data, what does it look like?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuser_1_rr_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 91,858 × 3\n#>    ibi_s   day time      \n#>    <dbl> <dbl> <hms>     \n#>  1 0.258     1 36617 secs\n#>  2 0.319     1 36618 secs\n#>  3 0.266     1 36618 secs\n#>  4 0.401     1 36618 secs\n#>  5 1.09      1 36619 secs\n#>  6 0.752     1 36620 secs\n#>  7 0.337     1 36620 secs\n#>  8 0.933     1 36621 secs\n#>  9 0.731     1 36622 secs\n#> 10 0.454     1 36623 secs\n#> # ℹ 91,848 more rows\n```\n:::\n:::\n\n\nTo make sure everything is so far reproducible within the\n`doc/learning.qmd` file, we will render the Quarto document to output an\nHTML file. Click the \"Render\" button at the top of the Source pane or by\ntyping {{< var keybind.render >}}. If it generates an HTML document\nwithout problems, we know our code is at least starting to be\nreproducible.\n\n## Exercise: Import the Actigraph data\n\n> Time: 15 minutes.\n\nPractice some more. Do the same thing with the `Actigraph.csv` dataset\nas we did for the `RR.csv`. But first:\n\n1.  Create a new header at the bottom of the `doc/learning.qmd` file and\n    call it `## Exercise: Import the Actigraph data`.\n2.  Below the header, create a new code chunk with\n    {{< var keybind.chunk >}}.\n\nUse the *same technique* as we used for the `RR.csv` data and read in\nthe `Actigraph.csv` file from `user_1/`.\n\n1.  Set the file path to the dataset with `here()`.\n2.  Read in a max of 100 rows for `n_max` and exclude the first column\n    with `col_select = -1`.\n3.  Use `spec()` to output the column specification and paste the\n    results into `col_types()`.\n4.  Render the Quarto document with {{< var keybind.render >}} to\n    regenerate the HTML document.\n5.  If everything works, run `{styler}` with {{< var keybind.styler >}}\n    and then **add and commit** the new changes to the Git history with\n\n    {{< var keybind.git >}}\n\n\n\nUse this template as a guide for completing this exercise.\n\n``` r\nuser_1_actigraph_file <- here(\"data-raw/mmash/user_1/___\")\nuser_1_actigraph_data_prep <- ___(\n    ___,\n    n_max = ___,\n    col_select = ___,\n    .name_repair = ___\n)\n___(user_1_actigraph_data_prep)\n\nuser_1_actigraph_data <- ___(\n    user_1_actigraph_file,\n    col_select = ___,\n    col_types = ___(\n        ___\n    ),\n    ___ = ___\n)\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n# Use first 100 or so lines to get spec\nuser_1_actigraph_file <- here(\"data-raw/mmash/user_1/Actigraph.csv\")\nuser_1_actigraph_data_prep <- vroom(\n  user_1_actigraph_file,\n  n_max = 100,\n  col_select = -1,\n  .name_repair = snakecase::to_snake_case\n)\nspec(user_1_actigraph_data_prep)\n\nuser_1_actigraph_data <- vroom(\n  user_1_actigraph_file,\n  col_select = -1,\n  col_types = cols(\n    col_skip(),\n    axis_1 = col_double(),\n    axis_2 = col_double(),\n    axis_3 = col_double(),\n    steps = col_double(),\n    hr = col_double(),\n    inclinometer_off = col_double(),\n    inclinometer_standing = col_double(),\n    inclinometer_sitting = col_double(),\n    inclinometer_lying = col_double(),\n    vector_magnitude = col_double(),\n    day = col_double(),\n    time = col_time(format = \"\")\n  ),\n  .name_repair = snakecase::to_snake_case\n)\n```\n:::\n\n\n## Summary\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nQuickly cover this before finishing the session and when starting the\nnext session.\n:::\n\n-   Use the appropriate package when importing a specific data file\n    (e.g. for `.xlsx` use `{readxl}`).\n-   Use `vroom()` for fast importing of plain text type files (e.g.\n    csv).\n-   Use `spec()` to diagnose importing issues.\n-   Use `col_types =` and `col_select =` arguments in `vroom()` to\n    import only the data you need.\n-   Fix column names to match a style using `.name_repair =` argument in\n    `vroom()`.\n-   For very large datasets, importing in the first 100-1000 rows using\n    `n_max =` to test that importing works fine before importing the\n    full dataset.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}